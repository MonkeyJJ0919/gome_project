1、定时任务的线程池配置
    //所有的定时任务都放在一个线程池中，定时任务启动时使用不同都线程。
    public class ScheduleConfig implements SchedulingConfigurer {
        @Override
        public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
            //设定一个长度10的定时任务线程池
            taskRegistrar.setScheduler(Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors()));
        }
    }

2、AppUserMessageSetDbCacheSyncJob  同步DB和Redis中的用户数据
（1）需要加分布式锁，jedis的setNX方法
（2）对于Redis中的用户数据，采用的是Hash结构


3、DeviceAttrPushJob 设备属性消息推送


4、LoadTimerJob  每天凌晨 0点，加载设备的定时任务（一个任务中有多个情景模式，一个情景模式中有多个联动设备）
（1）加锁保证线程安全

（2）定时任务放入mongo中，TimerTask表为基表，Timer表为任务执行中间表

（3）情景模式联动 也放在mongo中， Scene表。 executeReport表 是场景的执行记录表
    1）设备联动的顺序由在mongo中存储的顺序保证，遍历list，一次执行联动的设备


（4）设备定时任务执行的逻辑（两个要点：一、将任务从TimerTask中查询出来放入Timer中间表中，二、需要立即执行的任务，立即执行）
    1）对定时任务加锁，保证分布式部署服务的安全性
    2）首先从TimerTask表中，根据正则表达式查询需要当日执行的任务，如果执行时间小于120s则立即执行任务，否则，将任务放入Timer中间表中等待执行。
    3）执行任务：
               一、如果任务设置了情景模式（即联动），则进行设备的联动执行，设备联动的顺序由在mongo中存储的顺序保证，遍历list，一次执行联动的设备（此处有一个类似于递归调用的方式）。
                一个情景模式中有多个设备，如果设备没有延时执行，则立即执行，如果设备由延时执行，则把设备从新组装为任务放入Timer表中。

              二、如果是普通设备的执行：如果是第三方云设备，则调用第三方云的接口进行控制，如果是云对端设备，则进行dispatcher分发

    4）返回结果，
            一、如果成功：根据结果如果是情景模式任务，则标识情景模式完成，删除任务的第一动作，如果有下一个动作，则执行下一个动作（如果有延时则把任务放入timer中，将任务放入线程池中执行。）
                          如果是普通任务，则将任务从timer中删除

            二、如果失败：如果是情景模式任务，则设置失败状态，然后插入失败记录。一个动作错误，整个情景模式都取消


            三、如果出现异常：同二